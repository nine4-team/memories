import 'dart:convert';
import 'package:memories/models/queued_story.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:uuid/uuid.dart';

part 'offline_story_queue_service.g.dart'; // Will be generated by build_runner

const String _queueKey = 'queued_stories';

/// Service for managing offline queue of stories
/// 
/// Stories include audio recordings that need to be uploaded along with
/// transcripts and media attachments. This service handles local persistence
/// using SharedPreferences with JSON serialization, following the same pattern
/// as OfflineQueueService for moments.
@riverpod
OfflineStoryQueueService offlineStoryQueueService(OfflineStoryQueueServiceRef ref) {
  return OfflineStoryQueueService();
}

class OfflineStoryQueueService {
  /// Get all queued stories from storage
  Future<List<QueuedStory>> _getAllStories() async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = prefs.getString(_queueKey);
    if (jsonString == null) return [];
    
    try {
      final List<dynamic> jsonList = jsonDecode(jsonString);
      return jsonList
          .map((json) => QueuedStory.fromJson(json as Map<String, dynamic>))
          .toList();
    } catch (e) {
      // Handle corrupted JSON gracefully
      // Log error for debugging but don't crash
      return [];
    }
  }

  /// Save all stories to storage
  Future<void> _saveAllStories(List<QueuedStory> stories) async {
    final prefs = await SharedPreferences.getInstance();
    final jsonList = stories.map((s) => s.toJson()).toList();
    await prefs.setString(_queueKey, jsonEncode(jsonList));
  }

  /// Add a story to the queue
  /// 
  /// If a story with the same localId already exists, it will be updated.
  Future<void> enqueue(QueuedStory story) async {
    final stories = await _getAllStories();
    // Remove if already exists (update)
    stories.removeWhere((s) => s.localId == story.localId);
    stories.add(story);
    await _saveAllStories(stories);
  }

  /// Get all queued stories
  Future<List<QueuedStory>> getAllQueued() async {
    return await _getAllStories();
  }

  /// Get queued stories by status
  /// 
  /// Status values: 'queued', 'syncing', 'failed', 'completed'
  Future<List<QueuedStory>> getByStatus(String status) async {
    final stories = await _getAllStories();
    return stories.where((story) => story.status == status).toList();
  }

  /// Get a specific queued story by local ID
  Future<QueuedStory?> getByLocalId(String localId) async {
    final stories = await _getAllStories();
    try {
      return stories.firstWhere((s) => s.localId == localId);
    } catch (e) {
      return null;
    }
  }

  /// Update a queued story
  /// 
  /// This is equivalent to enqueue() for this implementation.
  Future<void> update(QueuedStory story) async {
    await enqueue(story);
  }

  /// Remove a queued story (after successful sync)
  Future<void> remove(String localId) async {
    final stories = await _getAllStories();
    stories.removeWhere((s) => s.localId == localId);
    await _saveAllStories(stories);
  }

  /// Get count of queued stories
  Future<int> getCount() async {
    final stories = await _getAllStories();
    return stories.length;
  }

  /// Get count by status
  /// 
  /// Status values: 'queued', 'syncing', 'failed', 'completed'
  Future<int> getCountByStatus(String status) async {
    final stories = await _getAllStories();
    return stories.where((story) => story.status == status).length;
  }

  /// Generate a deterministic local ID
  /// 
  /// Uses UUID v4 for uniqueness across app restarts and upgrades.
  static String generateLocalId() {
    return const Uuid().v4();
  }
}

