# Immediate Timeline Display and Title Processing Indicator

**Date:** 2025-12-02  
**Status:** ðŸŸ  Planning â€“ Implementation plan ready

## Problem Statement

Currently, when a user saves or captures a memory and navigates to the timeline:

1. **The memory does not immediately appear** in the timeline, even though it was successfully saved to the database.
2. **No visual feedback** indicates that the title is being generated by AI.
3. **The timeline does not automatically refresh** when the AI-generated title becomes available.

Users experience a delay and lack of feedback, making it unclear whether their memory was saved and when processing completes.

## Current Behavior

### Memory Save Flow

1. **Capture Screen** (`lib/screens/capture/capture_screen.dart`):
   - User saves memory via `MemorySaveService.saveMemory()`
   - Memory is created in database with a **fallback title** (e.g., "Untitled Moment")
   - `memory_processing_status` row is inserted with `state = 'scheduled'`
   - Success checkmark animation plays
   - Navigation occurs: `switchToTimeline()` is called
   - **No event is emitted** to notify the timeline of the new memory

2. **Timeline Screen** (`lib/screens/timeline/unified_timeline_screen.dart`):
   - Uses `UnifiedFeedController` to display memories
   - Listens to `MemoryTimelineUpdateBus` for update/delete events
   - **Does not listen for "created" events** (only `updated` and `deleted`)
   - Relies on:
     - Manual refresh (pull-to-refresh)
     - Realtime subscription for updates (but not for initial appearance)
     - Pagination to eventually show the memory

3. **Title Processing**:
   - Edge functions (`process-moment`, `process-story`, `process-memento`) generate titles
   - Title is updated in `memories.title` when processing completes
   - Realtime subscription may pick up the update, but only if the memory is already visible

### Processing Status System

- `memory_processing_status` table tracks processing state:
  - `scheduled` â†’ `processing` â†’ `complete` (or `failed`)
- `MemoryProcessingStatusProvider` provides stream-based access to status
- **Only `MomentCard`** currently has `_buildProcessingIndicator()` and it only shows in footer badges
- `StoryCard` and `MementoCard` do not currently show any processing indicators
- **Title area does not show processing state** in any card type

## Target Behavior

### Immediate Display

1. **When a memory is saved**:
   - Memory **immediately appears** in the timeline at the top (most recent)
   - Shows with fallback title (e.g., "Untitled Moment")
   - **Replace the title text with a processing indicator in the title area while AI is generating the title** (footer badges remain optional).
   - **This title-area behavior applies to both timeline preview cards and the memory detail screen** (use the same widget and styling in both places).

2. **While title is processing**:
  - Title area shows: **"Generating titleâ€¦"** with a loading indicator
  - The title-area indicator **replaces** the footer "Processing" badge to avoid duplicate status indicators; do not show both simultaneously
  - Memory is fully interactive (can be tapped to view detail)

3. **When title is generated**:
   - Timeline **automatically refreshes** the memory card to show the new title
   - Processing indicator disappears
   - Transition is smooth (no jarring re-render)

4. **Offline considerations**:
   - Offline-queued memories show appropriate status indicators
   - Processing indicators only appear for server-backed memories
   - When offline, show "Pending sync" instead of "Generating titleâ€¦"

## Implementation Plan

### Phase 1: Emit "Created" Events and Optimistic Timeline Updates

#### 1.1 Extend MemoryTimelineUpdateBus

**File:** `lib/providers/memory_timeline_update_bus_provider.dart`

- Add `MemoryTimelineEventType.created` to the enum
- Add `MemoryTimelineEvent.created(String memoryId)` constructor
- Add `emitCreated(String memoryId)` method to `MemoryTimelineUpdateBus`

**Rationale:** The bus currently only supports `updated` and `deleted`. We need a `created` event type to notify the timeline when a new memory is saved.

#### 1.2 Emit Created Event After Save

**File:** `lib/screens/capture/capture_screen.dart`

**Location:** After successful `saveMemory()` call (around line 382-386)

**Changes:**
- After `saveMemory()` succeeds (online save only), emit a `created` event with the new memory ID
- This should happen **before** navigation to timeline
- Use the `memoryId` returned from `MemorySaveResult`
- **Important:** Only emit `created` events for successful **online** saves. Offline saves are handled via the queue system and do not need bus events.

**Code pattern:**
```dart
// After saveMemory() succeeds (online path only)
final result = await saveService.saveMemory(...);
final bus = ref.read(memoryTimelineUpdateBusProvider);
bus.emitCreated(result.memoryId);
```

**Rationale:** The timeline needs to know about new server-backed memories immediately, not wait for a refresh or pagination. Offline saves already flow through the queue system.

#### 1.3 Handle Created Events in UnifiedFeedController

**File:** `lib/providers/unified_feed_provider.dart`

**Location:** `_handleTimelineUpdateEvent()` method (around line 163)

**Changes:**
- Add case for `MemoryTimelineEventType.created`
- When a created event is received:
  - **If online:** Fetch the memory by ID and prepend it to the feed so it appears at the top (most recent)
  - **If offline:** Do **not** attempt a network fetch; rely on the existing offline queue + `_handleQueueChange()` flow, which already ensures newly queued memories appear in the feed

**Implementation approach:**
- Use `repository.fetchMemoryById()` to get the full memory data when online
- Prepend the new memory to `state.memories` (taking care to dedupe by `id` / `serverId` / `localId`)
- Update state to trigger UI refresh

**Rationale:** The feed controller should react to created events by immediately adding server-backed memories to the visible feed. Note: `emitCreated()` should **only** be called for successful **online** saves; offline saves continue to flow through the queue system and do not need bus events.

### Phase 2: Show Processing Indicator in Title Area

#### 2.1 Determine Processing State for Title

**Files:** `lib/widgets/moment_card.dart`, `lib/widgets/story_card.dart`, `lib/widgets/memento_card.dart`

**Current state:**
- Cards use `displayTitle` getter from `TimelineMemory` which prefers `generatedTitle`, then `title`
- **Only `MomentCard`** currently shows a processing indicator, and that indicator appears **only in the footer badge area**
- `StoryCard` and `MementoCard` do **not** currently show any processing-state UI
- All cards need a reliable way to know whether the title is still being generated

**Approach:**
- For server-backed memories (`serverId != null`):
  - Watch `memoryProcessingStatusStreamProvider(serverId)`
  - If status is `scheduled` or `processing` AND `title` is fallback title:
    - Show processing indicator in title area
  - If status is `complete` or `failed`:
    - Show actual title (or fallback if generation failed)

- For offline-queued memories:
  - Show "Pending sync" or appropriate offline status
  - Do not show processing indicator (processing happens after sync)

#### 2.2 Create Title Processing Indicator Widget

**New file:** `lib/widgets/memory_title_with_processing.dart`

**Purpose:** Reusable widget that shows title or processing indicator based on state
**Usage:** Intended for timeline preview cards *and* the memory detail screen so the title-area experience is consistent across views.

**Props:**
- `TimelineMemory memory`
- `bool isOffline`

**Behavior:**
- Widget internally watches `memoryProcessingStatusStreamProvider(memory.serverId!)` for server-backed memories
- If offline and queued: **Replace the title text with the offline sync indicator (e.g., "Pending sync") using the same visual treatment as the processing indicator** (check `memory.isOfflineQueued` and `memory.offlineSyncStatus`)
- If online and processing (`scheduled` or `processing`): **Replace the title text with "Generating titleâ€¦" and a loading spinner** (do not show the fallback/generated title until processing completes)
- When the title-area indicator is shown, suppress the footer "Processing" badge to avoid duplicate status indicators
- If processing complete or no status: Show `memory.displayTitle`
- If processing failed: Show fallback title with subtle error indicator (optional)

**Rationale:** Centralizing this logic makes it easier to maintain and ensures consistency across card types.

#### 2.3 Update Card Widgets to Use Title Widget

**Files:**
- `lib/widgets/moment_card.dart`
- `lib/widgets/story_card.dart`  
- `lib/widgets/memento_card.dart`

**Changes:**
- Replace direct use of `memory.displayTitle` in title area with `MemoryTitleWithProcessing` widget
- Pass `memory` and `isOffline` props (widget handles processing status internally)
- Do **not** introduce any new footer badges as part of this work; only existing, non-title-related badges remain.

**Rationale:** Cards should delegate title rendering to the specialized widget to ensure consistent behavior.

#### Status display policy

- The **title-area indicator is authoritative** for title-generation and offline-queued state. When the title-area indicator is visible, **suppress** the footer "Processing" badge to avoid duplicate status displays.
- **Pending sync also lives in the title area** for queued memories, using the same visual treatment as the processing indicator; do not duplicate it in the footer.
- Existing footer badges (`Pending sync`, `Syncingâ€¦`, `Sync failed`, `Processing`) are **deprecated** once the title-area indicators are implemented and should be removed from the timeline cards as part of this work.
- The `Not available offline` chip may remain if we still need a non-title-related offline-availability hint; otherwise it should also be removed rather than left unused.
- Implementation note: `MemoryTitleWithProcessing` should be the single source of truth for whether a title-area indicator is shown; card footer rendering must not introduce any new status badges and should be cleaned up to remove the deprecated ones.

### Phase 3: Auto-Refresh When Title is Generated

#### 3.1 Leverage Existing Realtime Subscription

**File:** `lib/providers/unified_feed_provider.dart`

**Current state:**
- `_setupRealtimeSubscription()` listens for `memories` table **update** and **delete** events
- `_handleMemoryUpdate()` currently **removes** the memory from the feed via `removeMemory(memoryId)` but does **not** refetch or update it in-place
- Updated memories only reappear when the user manually refreshes or paginates the feed

This means realtime updates today **do not** automatically update titles in-place; they only ensure outdated entries are removed.

**Enhancement:**
- Update `_handleMemoryUpdate()` so that, when a memory in the current feed is updated and the device is online:
  - It fetches the updated memory by ID via `unifiedFeedRepository.fetchMemoryById()`
  - It updates that memory **in-place** in `state.memories` (similar to how the `updated` event handler in `_handleTimelineUpdateEvent()` works)
- When the `title` field changes, this in-place update causes the relevant card to rebuild with the new title
- The processing-status stream will automatically update the title-area indicator in tandem with the new data

**Rationale:** Realtime subscription already exists and should pick up title updates. We need to ensure it actually refreshes visible entries instead of just removing them.

#### 3.2 Add Processing Status Change Listener

**File:** `lib/providers/unified_feed_provider.dart`

**Enhancement (optional / not required for Phase 1):**
- We could subscribe to processing-status changes at the feed level, but this adds extra complexity and another cross-cutting listener.
- Instead, we will **rely on two existing mechanisms**:
  - Realtime `memories` table updates, with `_handleMemoryUpdate()` enhanced to refresh the specific memory in-place (see Phase 3.1).
  - Per-memory processing-status streams used directly by the card/title widgets (`memoryProcessingStatusStreamProvider(memoryId)`).

With these two pieces in place, a dedicated "processing status change listener" inside `UnifiedFeedController` is **not necessary** for the core behavior we want.

#### 3.3 Ensure Title Updates Trigger Card Refresh

**Files:** Card widgets (`moment_card.dart`, `story_card.dart`, `memento_card.dart`)

**Current state:**
- `MomentCard` watches `memoryProcessingStatusStreamProvider` for a **footer** processing badge
- `StoryCard` and `MementoCard` currently do **not** watch processing status at all
- All cards use `memory.displayTitle` in the title area, which is only updated when the underlying `TimelineMemory` instance in the feed changes (e.g., via refresh/pagination)

**Enhancement:**
- Introduce a dedicated title widget (see `MemoryTitleWithProcessing` in Phase 2.2) that:
  - Watches `memoryProcessingStatusStreamProvider(memory.serverId!)` for server-backed memories
  - Uses the current `TimelineMemory` from the feed for `displayTitle`
- Cards (`MomentCard`, `StoryCard`, `MementoCard`) will use this widget in the title area instead of rendering `displayTitle` directly
- When the feed replaces a `TimelineMemory` in-place (via bus `updated`/`created` events or realtime updates), the card rebuilds automatically with the new title
- The title widget's processing-status stream ensures the title-area indicator tracks status transitions (`scheduled` â†’ `processing` â†’ `complete` / `failed`)

**Rationale:** Cards need to react to both processing status changes and memory data updates to show the correct title at the right time.

### Phase 4: Offline Considerations

#### 4.1 Offline-Queued Memories

**Current state:**
- Offline memories are queued in `OfflineMemoryQueueService`
- Queue changes trigger feed updates via `_handleQueueChange()`
- Queued memories show "Pending sync" badge

**Enhancement:**
- When a memory is saved offline:
  - It should immediately appear in the timeline (from queue)
  - Show "Pending sync" in title area (not "Generating titleâ€¦")
  - Title area shows fallback title or input text preview
- When sync completes:
  - Memory transitions from queued to server-backed
  - Processing status becomes available
  - Show "Generating titleâ€¦" if processing is scheduled

**Rationale:** Offline memories have a different lifecycle. They need to sync first before processing can occur.

#### 4.2 Processing Status for Offline Memories

**Behavior:**
- Offline-queued memories: **No processing status** (processing happens after sync)
- After sync: Memory becomes server-backed, processing status becomes available
- Show appropriate indicators based on sync status, not processing status

**Implementation:**
- `MemoryTitleWithProcessing` widget should check `memory.isOfflineQueued`
- If queued: Show sync status, not processing status
- If synced but processing: Show processing status

**Rationale:** Processing only happens for server-backed memories. Offline memories need to sync first.

#### 4.3 Transition from Queued to Server-Backed

**File:** `lib/providers/unified_feed_provider.dart`

**Current state:**
- `_setupSyncListener()` removes queued entry when sync completes
- Server-backed version appears on next pagination/refresh

**Enhancement:**
- When sync completes:
  - Immediately fetch the server-backed memory
  - Replace queued entry with server-backed entry
  - This ensures processing status becomes available immediately

**Rationale:** Smooth transition from queued to server-backed ensures processing indicators appear as soon as possible.

## Technical Considerations

### Performance

- **Optimistic updates:** Adding memory immediately to feed is fast and provides instant feedback
- **Realtime subscriptions:** Already in place, should handle title updates efficiently
- **Processing status streams:** Per-memory streams are lightweight, but we should monitor if many concurrent streams cause issues

### Edge Cases

1. **Memory saved but processing fails:**
   - Show fallback title permanently
   - Optional: Show "Title generation failed" indicator
   - User can still edit title manually

2. **User navigates away before title is generated:**
   - Memory remains in timeline with processing indicator
   - When user returns, indicator updates based on current status
   - Realtime subscription ensures updates are received

3. **Multiple memories saved in quick succession:**
   - Each memory gets its own processing status stream
   - Feed controller handles multiple created events
   - UI updates incrementally as each title is generated

4. **Network interruption during processing:**
   - Processing continues on server
   - When connection restored, realtime subscription delivers update
   - Processing indicator updates accordingly

### Data Flow Summary

```
User saves memory
  â†“
MemorySaveService.saveMemory()
  â†“
Memory created in DB with fallback title
  â†“
memory_processing_status row created (state: 'scheduled')
  â†“
MemoryTimelineUpdateBus.emitCreated(memoryId)
  â†“
UnifiedFeedController receives created event
  â†“
Fetch memory by ID and prepend to feed
  â†“
Timeline displays memory with processing indicator in title area
  â†“
Edge function processes memory
  â†“
Title updated in memories table
  â†“
Realtime subscription delivers update
  â†“
UnifiedFeedController fetches updated memory and replaces it in-place in feed
  â†“
Card rebuilds with new title, indicator disappears
```

## Testing Considerations

### Manual Testing Scenarios

1. **Online save â†’ immediate display:**
   - Save a memory
   - Verify it appears immediately in timeline
   - Verify processing indicator shows in title area
   - Wait for title generation
   - Verify title updates automatically

2. **Offline save â†’ queue display:**
   - Go offline
   - Save a memory
   - Verify it appears in timeline with "Pending sync"
   - Go online
   - Verify sync occurs
   - Verify processing indicator appears after sync
   - Verify title generates and updates

3. **Multiple rapid saves:**
   - Save 3-4 memories quickly
   - Verify all appear in timeline
   - Verify each shows processing indicator
   - Verify titles update independently

4. **Navigation during processing:**
   - Save memory
   - Navigate to detail view
   - Navigate back to timeline
   - Verify processing indicator still shows (if not complete)
   - Verify title updates when complete

### Automated Testing

- Unit tests for `MemoryTimelineUpdateBus` with created events
- Unit tests for `UnifiedFeedController` handling created events
- Widget tests for `MemoryTitleWithProcessing` widget
- Integration tests for full save â†’ display â†’ update flow

## Implementation Order

1. **Phase 1** (Foundation): Emit created events and handle in feed controller
2. **Phase 2** (UI): Show processing indicator in title area
3. **Phase 3** (Auto-refresh): Ensure title updates trigger refresh
4. **Phase 4** (Offline): Handle offline edge cases

Each phase can be implemented and tested independently, allowing for incremental rollout.

## Success Criteria

- âœ… Memory appears in timeline immediately after save
- âœ… Processing indicator shows in title area while title is being generated
- âœ… Timeline automatically refreshes when title is generated
- âœ… Offline memories show appropriate status (not processing indicator)
- âœ… Smooth transitions with no jarring UI updates
- âœ… Works correctly for all memory types (moments, stories, mementos)

## Related Documentation

- `docs/architectural_fixes/memory-timeline-update-bus.md` - Update bus architecture
- `docs/ui-improvements/memory-processing-notification-ui-companion.md` - Processing UI patterns
- `docs/architectural_fixes/memory-processing-and-notification-architecture.md` - Processing architecture
- `docs/architectural_fixes/offline-memory-viewing-editing/README.md` - Offline capabilities

